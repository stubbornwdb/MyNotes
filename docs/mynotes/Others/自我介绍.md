# 一、个人介绍

面试官你好，我叫xx，我的专业是计算机科学与技术，我在校期间利用自己的课外时间去学了Java、Spring、Mybatis等框架，并尝试写过一个简单的RPC框架，这个框架主要使用Netty进行通信，然后还是实现了一些常见的序列化方法以及负载均衡算法。另外，我参加过泰迪杯的数据挖掘挑战赛，主要是做一个政务文本的分类聚类这些，拿到了国家三等价，还参加过蓝桥的算法比赛，也拿到了广东省的二等奖。我有自己的公众号，平时会在上面分享一些自己学习算法等方面的内容。生活中我是一个比较积极乐观的人，喜欢运动打球放松自己，我的大致情况就是这样~

# 二、RPC

### 1. RPC介绍

**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。

**为什么要 RPC ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。

**RPC 能帮助我们做什么呢？** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。

举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

### 2. RPC组成

1. **客户端（服务消费端）** ：调用远程方法的一端。
2. **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
3. **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。
4. **服务端 Stub（桩）** ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。
5. **服务端（服务提供端）** ：提供远程方法的一端。

### 3. RPC调用过程

1. 服务消费端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:`RpcResponse` ，这样也就得到了最终结果。

### 4. RPC 实现可靠性、安全性



# 三、权限管理

```
使用基于RBAC模型进行设计数据库表，构建“用户-角色-权限”的授权模型

通过Shiro相关权限注解、及jwt进行系统的认证和授权

使用Redis作为缓存的初始化，并用于保存登录Token及登录用户信息

统一参数校验并使用SpringAOP记录操作日志

自定义注解实现接口的限流
```

### 1.数据库表怎么设计的？

关系：

![](E:\博客\introduce\9.png)



角色和权限之间的关系使用的是经典的RBAC（Role-Based Access Control，基于角色的访问控制）模型。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。

表：

1.用户-角色表

![](E:\博客\introduce\1.jpg)

2.用户配置表

![](E:\博客\introduce\2.png)

3.用户表

![](E:\博客\introduce\3.png)

4.角色-菜单表

![](E:\博客\introduce\4.png)

5.角色表

![](E:\博客\introduce\5.png)

6.菜单表

![](E:\博客\introduce\6.png)

7.登录日志表

![](E:\博客\introduce\7.jpg)

8.日志表

![](E:\博客\introduce\8.png)

常见的认证方式：[见](https://www.cnblogs.com/fengzheng/p/8416393.html)



比如获取用户名为mrbrid的用户权限过程为：

1. 通过mrbrid的user_id从t_user_role表获取对应的role_id；
2. 通过第1步获取的role_id从t_role_menu表获取对应的menu_id；
3. 通过第2步获取的menu_id从t_menu获取menu相关信息（t_menu表的permission为权限信息）。

### 2.日志是怎么实现的？

使用AOP配合注解使用

[Spring Boot AOP记录用户操作日志](https://mrbird.cc/Spring-Boot-AOP%20log.html)

**spring AOP的使用，分三个步骤，记住这三个步骤，AOP就不会有问题：**

- 确定目标对象（target—>bean） 通俗的来讲就是“哪个方法需要增强，你就把他交给spring。
- 编写Advice通知方法 （增强代码） 就是写增强代码
- 配置切入点和切面 第三点的作用就是：让你的增强代码作用于你要增强的目标对象上

代码：

声明一个切面

```
/**
 * AOP 记录用户操作日志
 */
@Slf4j
@Aspect
@Component
public class LogAspect {

    @Autowired
    private FebsProperties febsProperties;

    @Autowired
    private LogService logService;

    @Pointcut("@annotation(cc.mrbird.febs.common.annotation.Log)")
    public void pointcut() {
        // do nothing
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        Object result = null;
        long beginTime = System.currentTimeMillis();
        // 执行方法
        result = point.proceed();
        // 获取 request
        HttpServletRequest request = HttpContextUtil.getHttpServletRequest();
        // 设置 IP 地址
        String ip = IPUtil.getIpAddr(request);
        // 执行时长(毫秒)
        long time = System.currentTimeMillis() - beginTime;
        if (febsProperties.isOpenAopLog()) {
            // 保存日志
            String token = (String) SecurityUtils.getSubject().getPrincipal();
            String username = "";
            if (StringUtils.isNotBlank(token)) {
                username = JWTUtil.getUsername(token);
            }

            SysLog log = new SysLog();
            log.setUsername(username);
            log.setIp(ip);
            log.setTime(time);
            logService.saveLog(point, log);
        }
        return result;
    }
}


/**
 * Log注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
}


```



> [具体使用](https://blog.csdn.net/java_green_hand0909/article/details/90238242)
>
> @Aspect:作用是把当前类标识为一个切面供容器读取
>
> @Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。
>
> # Pointcut
>
> 表示式(expression)和签名(signature)
>
> ```
> //Pointcut表示式
> @Pointcut("execution(* com.savage.aop.MessageSender.*(..))")
> 
> //Point签名
> private void log(){} 
> ```
>
> 由下列方式来定义或者通过 &&、 ||、 !、 的方式进行组合：
>
> - execution：用于匹配方法执行的连接点；
> - within：用于匹配指定类型内的方法执行；
> - this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；    
> - target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；
> - args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；
> - @within：用于匹配所以持有指定注解类型内的方法；
> - @target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；
> - @args：用于匹配当前执行的方法传入的参数持有指定注解的执行；
> - @annotation：用于匹配当前执行方法持有指定注解的方法；
>
> @Around：环绕增强，相当于MethodInterceptor
>
> 
>
> @AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行
>
> @Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有
>
> @AfterThrowing：异常抛出增强，相当于ThrowsAdvice
>
> @After: final增强，不管是抛出异常或者正常退出都会执行


注解的使用：[详情见](https://www.jianshu.com/p/596d389282a0)

### 3. 接口限流是怎么实现的

[springboot + aop + Lua分布式限流的最佳实践](https://juejin.im/post/6844904118318809101#heading-5)

[常见限流方案](https://juejin.im/post/6844904161604009997)

对于高并发的系统，有三把利器用来保护系统：**缓存**、**降级** 和 **限流**。限流常见的应用场景是秒杀、下单和评论等 **突发性** 并发问题。

1. **缓存** 的目的是提升 **系统访问速度** 和 **系统吞吐量**。
2. **降级** 是当服务 **出问题** 或者影响到核心流程的性能，则需要 **暂时屏蔽掉**，待 **高峰** 或者 **问题解决后** 再打开。
3. 有些场景并不能用 **缓存** 和 **降级** 来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（最新的评论）。因此需有一种手段来限制这些场景的 **并发/请求量**，即 **限流**。

限流的目的是通过对 **并发访问/请求进行** 限速，或者一个 **时间窗口** 内的的请求进行限速来 **保护系统**，一旦达到限制速率则可以 **拒绝服务**（定向到错误页或告知资源没有了）、**排队** 或 **等待**（比如秒杀、评论、下单）、降级（返回托底数据或默认数据，如商品详情页库存默认有货）。

项目中`@Limit`注解可以实现接口的限流。即规定一段时间内最多可以访问该接口的次数，超过这个次数则抛出`LimitAccessException`异常。

`@Limit`注解如下所示：

```
import cc.mrbird.common.domain.LimitType;
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Limit {
    // 资源名称，用于描述接口功能
    String name() default "";
    // 资源 key
    String key() default "";
    // key prefix
    String prefix() default "";
    // 时间的，单位秒
    int period();
    // 限制访问次数
    int count();
    // 限制类型
    LimitType limitType() default LimitType.CUSTOMER;
}
```

其中，limitType包含传统类型限流和根据IP限流，其为枚举类型：

```
public enum LimitType {
    // 传统类型
    CUSTOMER,
    // 根据 IP 限制
    IP;
}
```

切面

```
/**
 * 接口限流
 */
@Slf4j
@Aspect
@Component
public class LimitAspect {

    private final RedisTemplate<String, Serializable> limitRedisTemplate;

    @Autowired
    public LimitAspect(RedisTemplate<String, Serializable> limitRedisTemplate) {
        this.limitRedisTemplate = limitRedisTemplate;
    }

    @Pointcut("@annotation(cc.mrbird.febs.common.annotation.Limit)")
    public void pointcut() {
        // do nothing
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();

        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        Limit limitAnnotation = method.getAnnotation(Limit.class);
        LimitType limitType = limitAnnotation.limitType();
        String name = limitAnnotation.name();
        String key;
        String ip = IPUtil.getIpAddr(request);
        int limitPeriod = limitAnnotation.period();
        int limitCount = limitAnnotation.count();
        switch (limitType) {
            case IP:
                key = ip;
                break;
            case CUSTOMER:
                key = limitAnnotation.key();
                break;
            default:
                key = StringUtils.upperCase(method.getName());
        }
        ImmutableList<String> keys = ImmutableList.of(StringUtils.join(limitAnnotation.prefix() + "_", key, ip));
        String luaScript = buildLuaScript();
        RedisScript<Number> redisScript = new DefaultRedisScript<>(luaScript, Number.class);
        Number count = limitRedisTemplate.execute(redisScript, keys, limitCount, limitPeriod);
        log.info("IP:{} 第 {} 次访问key为 {}，描述为 [{}] 的接口", ip, count, keys, name);
        if (count != null && count.intValue() <= limitCount) {
            return point.proceed();
        } else {
            throw new LimitAccessException("接口访问超出频率限制");
        }
    }

    /**
     * 限流脚本
     * 调用的时候不超过阈值，则直接返回并执行计算器自加。
     *
     * @return lua脚本
     */
    private String buildLuaScript() {
        return "local c" +
                "\nc = redis.call('get',KEYS[1])" +
                "\nif c and tonumber(c) > tonumber(ARGV[1]) then" +
                "\nreturn c;" +
                "\nend" +
                "\nc = redis.call('incr',KEYS[1])" +
                "\nif tonumber(c) == 1 then" +
                "\nredis.call('expire',KEYS[1],ARGV[2])" +
                "\nend" +
                "\nreturn c;";
    }

}
```

### 4.全局异常处理

[全局异常处理](https://juejin.im/post/6844903788638306311)

### 5.认证和授权流程

- **认证**

身份验证，即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。
在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：
**principals：**身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号。
**credentials：**证明/凭证，即只有主体知道的安全值，如密码/数字证书等。
最常见的principals和credentials组合就是用户名/密码了。接下来先进行一个基本的身份认证。

另外两个相关的概念是之前提到的Subject及Realm，分别是主体及验证主体的数据源。

1、首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；
2、SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；
3、Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；
4、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；
5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。

- **授权**

授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。

**主体**

主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。
**资源**
在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。
**权限**
安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：
访问用户列表页面
查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）
打印文档等等。。。

如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro不会去做这件事情，而是由实现人员提供。

Shiro支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的）

1)系统调用subject主体对象相关方法将用户权限信息(例如isPermitted)递交给SecurityManager
2)SecurityManager将权限检测操作委托给Authorizer授权管理器对象
3)Authorizer授权管理器将用户信息委托给realm。
4)Realm访问数据库获取用户权限信息(有没有权限，有什么样的权限)并封装。

5)Authorizer对用户授权信息进行判定(判断用户访问资源时需要什么权限，假如用户所具有的权限包含这个资源访问时所需要的权限，那么用户就可以访问这个资源了)。

不是每一个用户都能访问系统中的所有资源，能访问哪些资源需要有一个授权的过程，这个授权的对象叫做Authorizer。

[什么是JWT](https://www.jianshu.com/p/576dbf44b2ae)

### 6. 有用到事务吗？怎么用的？

[事务@Transactional](https://blog.csdn.net/nextyu/article/details/78669997)

Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编程式和声明式的两种方式。编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于 `@Transactional` 注解的方式。

Spring Boot 使用事务非常简单，首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可。



**@Transactional 事务实现机制**

在应用系统调用声明了 `@Transactional` 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据 `@Transactional` 的属性配置信息，这个代理对象决定该声明 `@Transactional` 的目标方法是否由拦截器 `TransactionInterceptor` 来使用拦截，在 `TransactionInterceptor` 拦截时，会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器 `AbstractPlatformTransactionManager` 操作数据源 `DataSource` 提交或回滚事务。

Spring AOP 代理有 `CglibAopProxy` 和 `JdkDynamicAopProxy` 两种，以 `CglibAopProxy` 为例，对于 `CglibAopProxy`，需要调用其内部类的 `DynamicAdvisedInterceptor` 的 intercept 方法。对于 `JdkDynamicAopProxy`，需要调用其 invoke 方法。

### 7.架构设计

[架构设计](https://ifeve.com/am-hierarchy/)



